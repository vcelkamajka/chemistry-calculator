import pandas as pd
import matplotlib.pyplot as plt
import math
import numpy as np
import scipy
from statsmodels.graphics.gofplots import qqplot # for qq plot
from scipy.stats.distributions import norm # for qq plot
from scipy.stats import halfnorm
from scipy.stats import norm
from scipy.stats import f_oneway # anova
from mpl_toolkits.mplot3d import Axes3D
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from statsmodels.stats.outliers_influence import variance_inflation_factor

file_read = pd.read_csv('CFAE DOE.csv')

print(file_read[['Run', 'CFAE Conc. (mM)', '% Glycerol', '% Castor Oil', '% Water', '% Quercetin Encapsulation']])

run_list = [1,2,3,4,5,6,7,8]
cfae_list = [-1 if i == 0.01 else 1 if i == 0.08 else i for i in file_read['CFAE Conc. (mM)']]
cos_list = [-1 if i == 0.1 else 1 if i == 0.2 else i for i in file_read['% Glycerol']]
oil_list = [-1 if i == 0.35 else 1 if i == 0.2 else i for i in file_read['% Castor Oil']]
water_list = file_read['% Water']
ee_list = file_read['% Quercetin Encapsulation']

def avg_response(list_name, ee_list):
    high = []
    low = []
    for i in range(len(ee_list)):
        if list_name[i] == 1:
            high.append(ee_list[i])
        if list_name[i] == -1:
            low.append(ee_list[i])
    list_avg = (sum(high) / len(high)) - (sum(low) / len(low))
    return list_avg

avg_cfae = avg_response(cfae_list, ee_list)
avg_cos = avg_response(cos_list, ee_list)
avg_oil = avg_response(oil_list, ee_list)
avg_response_list = [avg_cfae, avg_cos, avg_oil]

avg_response_list_pd = pd.DataFrame({'Run': ['Avg. H/L Response'], 'CFAE Conc. (mM)': avg_cfae, '% Glycerol': avg_cos, '% Castor Oil': avg_oil, '% Water': ['N/A'], '% Quercetin Encapsulation': ['N/A']})

# note to self: adding [] in ({}) will make the LIST be printed, not its individual elements.
normalised_pd = pd.DataFrame({'Run': run_list, 'CFAE Conc. (mM)': cfae_list, '% Glycerol': cos_list, '% Castor Oil': oil_list, '% Water': water_list, '% Quercetin Encapsulation': ee_list})
normalised_avg_pd = pd.concat([normalised_pd, avg_response_list_pd])
normalised_avg_pd.reset_index(drop=True, inplace=True)
print(normalised_avg_pd)

normalised_avg_pd.to_csv('CFAE DOE Python File.csv', index = False)

abs_average = [abs(avg_response_list[i]) for i in range(len(avg_response_list))]
sorted_avg = sorted(abs_average)


# Blom plotting position formula is used to find the cum prob - good for small datasets.
# cum_prob = (rank - 0.375) / (n + 0.25)
# rank is position from 1 to n based on size (1, 2, 4, 34, 645 ...)
# 0.325 is a constant of the equation.

rank_list = [i + 1 - 0.375 for i in range(len(sorted_avg))]


cum_prob_list = []
theory_z_list = []
for i in range(len(rank_list)):
    cum_prob = rank_list[i] / (len(rank_list) + 0.25)
    cum_prob_list.append(cum_prob)
    theory_z = halfnorm.ppf(cum_prob)
    theory_z_list.append(theory_z)
# print(theory_z_list)
# print(cum_prob_list)

plt.scatter(abs_average, theory_z_list)

plt.xlabel('Absolute Average (H-L)')
plt.ylabel('Theoretical Z-Value')
plt.show()

# https://www.geeksforgeeks.org/machine-learning/optimizing-machine-learning-models-using-response-surface-methodology/
# This just shows the design of the three factor DOE, no useful information.

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(file_read['CFAE Conc. (mM)'], file_read['% Glycerol'], file_read['% Castor Oil'], c='r', marker='o')
ax.set_xlabel('CFAE Conc. (mM)')
ax.set_ylabel('% Glycerol')
ax.set_zlabel('% Castor Oil')
plt.show()

# Need to know model the data with regression and then generate data on the regression lines.
# https://scikit-learn.org/stable/modules/preprocessing.html#polynomial-features

x_factor = 'CFAE Conc. (mM)'
y_factor = '% Glycerol'
z_factor = '% Castor Oil'

factors = [x_factor, y_factor, z_factor]
response = '% Quercetin Encapsulation'

X = file_read[factors]
Y = file_read[response]

# Need to get the model for the regression of the three variables.

poly = PolynomialFeatures(1) # quadratic regression selected (1: linear, 2: quadratic, 3: cubic ... )
x_poly = poly.fit_transform(X) # gives the regression values (x, x1, x1*x2 ...)
model = LinearRegression() # linear regression model.
model.fit(x_poly, Y) # fits the data
print('Model coefficients : ', model.coef_) # Beta coefficients

# Correlation coefficient of model fit / as there is no centre point - higher polynomial = higher r2 !!!

y_prediction = model.predict(x_poly)
y_pred_flat = y_prediction.flatten() #flatten is identical to ravel
corr_coeff = r2_score(Y, y_pred_flat)
mse = mean_squared_error(Y, y_pred_flat)
print(f'Correlation coefficient is {corr_coeff:.4f}.') # as there is no centre point - higher polynomial = higher r2 also cannot utilise quadratic or higher
print(f'Mean squared error is {mse:.4f}.')
print("Intercept:", model.intercept_)


# VIF of 1 is ideal (no multicollinearity)
# VIF of < 5 is low to mod. multicollinearity
# VIF of > 5 is high (may have to remove or combine remove correlated variables)
# VIF > 10 is v. high.

vif_factors = file_read[['CFAE Conc. (mM)', '% Glycerol', '% Castor Oil']]
vif_data = pd.DataFrame()   # makes empty DF
vif_data['Feature'] = vif_factors.columns   # Features are the column names of the file read

vif_data['VIF'] = [variance_inflation_factor(vif_factors, i) for i in range(len(vif_factors.columns))] # VIF is equal to the VIF of the factors and the data indices
print(vif_data)

for i in range(len(vif_data['VIF'])):
    if vif_data['VIF'][i] > 5:
        print(f'VIF above 5 for {vif_data['Feature'][i]}: ',round(vif_data['VIF'][i], 2)) # index of column returned for VIF > 5


#----------------------------------------------------------------------

x_range = np.linspace(X[x_factor].min(), X[x_factor].max(), 30) # gets 30 points from min to max
y_range = np.linspace(X[y_factor].min(), X[y_factor].max(), 30)
#z_range = [X[z_factor].min(), X[z_factor].mean(), X[z_factor].max()]
z_range = [0.20, 0.25, 0.30, 0.35]

[x1, x2] = np.meshgrid(x_range, y_range) # creates combo of the two variables


# need to now pair each x1, x2 with a z value which will be constant for 3/4 diff plots.

#fig, axes = plt.subplots(1, 3, figsize=(18, 5)) # makes the figure with 3 plots in 1 row with the image size 18 x 5
fig, axes = plt.subplots(1, 4, figsize=(15, 5))

for i, z_value in enumerate(z_range): # ultimately returns (index, value) -> (0, 20%) ...
    flat = pd.DataFrame({x_factor: x1.ravel(), y_factor: x2.ravel(), z_factor: np.full(x1.size, z_value)}) # np.full matches data size of x1 size and then puts in the z_value for the values
    grid_poly = poly.transform(flat) # transforms to quadratic regression
    y_pred = model.predict(grid_poly).reshape(x1.shape) # predicts the response and converts into a 2D grid which we need for contour

    contour = axes[i].contourf(x1, x2, y_pred, levels = 30, cmap = 'plasma')
    # i here is the index for each value of % castor 0 = 20%, 1 = 27.5%, 2 = 35% ...
    axes[i].scatter(X[x_factor], X[y_factor], c = 'red', s = 30)
    # shows each point from DOE on graph (real data)
    axes[i].set_xlabel(x_factor)
    axes[i].set_ylabel(y_factor)
    axes[i].set_title(f'{z_factor} = {z_value:.2f}')

fig.colorbar(contour, ax=axes, orientation='horizontal', label=response)
plt.savefig('CFAE DOEs.png')
plt.show()

fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
a = ax.plot_surface(x1, x2, y_pred, cmap='plasma')
ax.set_xlabel('CFAE Conc. (mM)')
ax.set_ylabel('% Glycerol')
ax.set_zlabel('% Quercetin Encapsulation')
ax.set_title('CFAE Conc. (mM) vs. % Glycerol')
# fig.colorbar(a, shrink=0.5, label = '% Quercetin Encapsulation') # the color bar maps to the colour map of response
# obsolete as the z axis is the response
plt.show()

# Make a list of the responses from the predicted variables.

x_factor = 'CFAE Conc. (mM)' # reminder that x factor is cfae.
Y = file_read[response] # quercetin encapsulation

# ANOVA test for variance ---------------------------------------------------------------------

f_statistic, p_value = f_oneway(file_read['CFAE Conc. (mM)'], file_read['% Glycerol'], file_read['% Castor Oil'])
print(f'F-statistic for ANOVA: {f_statistic:.4f}')
print(f'P-value for ANOVA: {p_value:.10f}')

if p_value < 0.05:
    print('Mean(s) are non-equal!')
else:
    print('Mean(s) are equal!')

